package com.eden.orchid.api.generators;

import com.caseyjbrooks.clog.Clog;
import com.eden.common.json.JSONElement;
import com.eden.common.util.EdenUtils;
import com.eden.orchid.api.OrchidContext;
import com.eden.orchid.api.indexing.OrchidIndex;
import com.eden.orchid.api.indexing.OrchidInternalIndex;
import com.eden.orchid.api.options.annotations.BooleanDefault;
import com.eden.orchid.api.options.annotations.Description;
import com.eden.orchid.api.options.annotations.Option;
import com.eden.orchid.api.resources.resource.FreeableResource;
import com.eden.orchid.api.theme.Theme;
import com.eden.orchid.api.theme.pages.OrchidPage;
import com.eden.orchid.utilities.OrchidUtils;
import lombok.Getter;
import lombok.Setter;
import org.json.JSONObject;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Stream;

/**
 * @since v1.0.0
 * @orchidApi services
 */
@Singleton
public final class GeneratorServiceImpl implements GeneratorService {

    private final Set<OrchidGenerator> allGenerators;
    private OrchidContext context;

    @Getter
    private BuildMetrics metrics;

    @Getter @Setter
    @Option
    @Description("Whitelist the generators in this array, only indexing and generating these generators.")
    private String[] enabled;

    @Getter @Setter
    @Option
    @Description("Blacklist the generators in this array, not indexing and generating these generators.")
    private String[] disabled;

    @Getter @Setter
    @Option
    @Description("The indices generated by an Orchid site can be included in the build of another Orchid site, to " +
            "make intelligent links between the two sites. The index at `meta/indices.json` will crawl all the " +
            "sub-indices of that site, or just a single one of that site's sub-indices can be included."
    )
    private String[] externalIndices;

    @Getter @Setter
    @Option @BooleanDefault(false)
    @Description("By default Generators run serially in priority order, but this flag will allow all generators to be" +
            "indexed in parallel for improved performance. Not suitable for builds where later generators depend on " +
            "the pages indexed by higher-priority generators."
    )
    private boolean parallelIndexing;

    @Getter @Setter
    @Option @BooleanDefault(false)
    @Description("By default Generators run serially in priority order, but this flag will allow all generators to " +
            "render in parallel for improved performance (the pages from that generator are still rendered " +
            "serially by default). Not suitable for builds where later generators depend on the pages rendered by " +
            "higher-priority generators."
    )
    private boolean parallelGeneration;

    @Inject
    public GeneratorServiceImpl(Set<OrchidGenerator> generators, BuildMetrics metrics) {
        this.allGenerators = new TreeSet<>(generators);
        this.metrics = metrics;
    }

    @Override
    public void initialize(OrchidContext context) {
        this.context = context;
    }

    @Override
    public String[] getGeneratorKeys(String[] include, String[] exclude) {
        return getFilteredGenerators(getFilteredGenerators(false), include, exclude)
                .map(OrchidGenerator::getKey)
                .toArray(String[]::new);
    }

// Indexing phase
//----------------------------------------------------------------------------------------------------------------------

    @Override
    public void startIndexing() {
        metrics.startIndexing(allGenerators);

        context.clearIndex();

        buildInternalIndex();
        buildExternalIndex();

        context.mergeIndices(context.getInternalIndex(), context.getExternalIndex());

        metrics.stopIndexing();
    }

    private void buildInternalIndex() {
        getFilteredGenerators(parallelIndexing).forEach(this::indexGenerator);
    }

    private void indexGenerator(OrchidGenerator generator) {
        Clog.d("Indexing [{}: {}]", generator.getPriority(), generator.getKey());
        metrics.startIndexingGenerator(generator.getKey());

        JSONElement el = context.query(generator.getKey());
        if (EdenUtils.elementIsObject(el)) {
            generator.extractOptions(context, (JSONObject) el.getElement());
        }
        else {
            generator.extractOptions(context, new JSONObject());
        }

        // get the pages from a generator
        List<? extends OrchidPage> generatorPages = generator.startIndexing();
        if (generatorPages != null && generatorPages.size() > 0) {
            OrchidInternalIndex index = new OrchidInternalIndex(generator.getKey());
            generatorPages.stream().filter(Objects::nonNull).forEach(page -> {
                page.setGenerator(generator);
                page.setIndexed(true);
                index.addToIndex(generator.getKey() + "/" + page.getReference().getPath(), page);
                freePage(page);
            });
            context.addChildIndex(generator.getKey(), index);
        }

        // get the collections from a generator
        List<? extends OrchidCollection> generatorCollections = generator.getCollections();
        if (generatorCollections != null && generatorCollections.size() > 0) {
            context.addCollections(generatorCollections);
        }

        // notify the generator is finished indexing
        if (generatorPages != null && generatorPages.size() > 0) {
            metrics.stopIndexingGenerator(generator.getKey(), generatorPages.size());
        }
        else {
            metrics.stopIndexingGenerator(generator.getKey(), 0);
        }
    }

    private void buildExternalIndex() {
        if(!EdenUtils.isEmpty(externalIndices)) {
            for (String externalIndex : externalIndices) {
                JSONObject indexJson = this.context.loadAdditionalFile(externalIndex);
                if (indexJson != null) {
                    OrchidIndex index = OrchidIndex.fromJSON(context, indexJson);
                    context.addExternalChildIndex(index);
                }
            }
        }
    }

// Generation Phase
//----------------------------------------------------------------------------------------------------------------------

    @Override
    public void startGeneration() {
        metrics.startGeneration();
        getFilteredGenerators(parallelGeneration).forEach(this::useGenerator);
        metrics.stopGeneration();
    }

    private void useGenerator(OrchidGenerator generator) {
        Clog.d("Generating [{}: {}]{}", generator.getPriority(), generator.getKey(), (generator.isParallel()) ? " in parallel" : "");

        metrics.startGeneratingGenerator(generator.getKey());

        List<? extends OrchidPage> generatorPages = null;
        if (!EdenUtils.isEmpty(generator.getKey())) {
            generatorPages = context.getGeneratorPages(generator.getKey());
        }
        if (generatorPages == null) {
            generatorPages = new ArrayList<>();
        }

        Stream<? extends OrchidPage> generatorPagesStream = generator.isParallel() ? generatorPages.parallelStream() : generatorPages.stream();

        Theme customTheme = context.doWithTheme(generator.getTheme(), () -> generator.startGeneration(generatorPagesStream));
        if(customTheme != null) {
            Clog.i("[{}] Generator pages rendered with [{}] Theme.", generator.getKey(), customTheme.getKey());
        }

        metrics.stopGeneratingGenerator(generator.getKey());
    }

    public void onPageGenerated(OrchidPage page, long millis) {
        metrics.onPageGenerated(page, millis);
        freePage(page);
    }

// Utilities
//----------------------------------------------------------------------------------------------------------------------

    Stream<OrchidGenerator> getFilteredGenerators(boolean parallel) {
        return getFilteredGenerators(parallel, enabled, disabled);
    }

    Stream<OrchidGenerator> getFilteredGenerators(boolean parallel, String[] include, String[] exclude) {
        Stream<OrchidGenerator> generatorStream = (parallel) ? allGenerators.parallelStream() : allGenerators.stream();
        return getFilteredGenerators(generatorStream, include, exclude);
    }

    Stream<OrchidGenerator> getFilteredGenerators(Stream<OrchidGenerator> generators, String[] include, String[] exclude) {
        Stream<OrchidGenerator> generatorStream = generators;

        if(!EdenUtils.isEmpty(exclude)) {
            generatorStream = generatorStream
                    .filter(generator -> !OrchidUtils.inArray(generator, exclude, (generator1, s) -> generator1.getKey().equals(s)));
        }

        if(!EdenUtils.isEmpty(include)) {
            generatorStream = generatorStream
                    .filter(generator -> OrchidUtils.inArray(generator, include, (generator1, s) -> generator1.getKey().equals(s)));
        }

        return generatorStream;
    }

    private void freePage(OrchidPage page) {
        if (page.getResource() instanceof FreeableResource) {
            ((FreeableResource) page.getResource()).free();
        }
    }

}
